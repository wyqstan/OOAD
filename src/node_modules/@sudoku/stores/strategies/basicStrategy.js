import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';
import { nextBoard, updateCandidates } from '@sudoku/stores/boardForSolve';

//initialize candidates
export function initCandidates(){
    for(let row = 0; row < SUDOKU_SIZE; row++){
        for(let col = 0; col < SUDOKU_SIZE; col++){
            if(nextBoard[row][col][0] === 0){
                for(let num = 1; num <= 9; num++){
                    nextBoard[row][col][num] = 1;
                }
            }
        }
    }

    //update candidates
    for(let row = 0; row < SUDOKU_SIZE; row++){
        for(let col = 0; col < SUDOKU_SIZE; col++){
            if(nextBoard[row][col][0] != 0){
                updateCandidates(row, col);
            }
        }
    }
}

//
export function hidingSingles(){
    let isChange = true;
    while(isChange){
        isChange = false;
        //last remaining cell in row
        for(let row = 0; row < SUDOKU_SIZE; row++){
            for (let num = 1; num <= 9; num++) {
                let possiblePositions = [];
                for (let col = 0; col < SUDOKU_SIZE; col++) {
                    if (nextBoard[row][col][num] === 1) {
                        possiblePositions.push([row, col]);
                    }
                }
                if (possiblePositions.length === 1) {
                    // 该数字在该行中只有一个可能位置
                    const [i, j] = possiblePositions[0];
                    nextBoard[i][j][0] = num;
                    updateCandidates(i, j);  // 更新候选值矩阵
                    isChange = true;
                }
            }
        }

        //last remaining cell in column
        for(let col = 0; col < SUDOKU_SIZE; col++){
            for (let num = 1; num <= 9; num++) {
                let possiblePositions = [];
                for (let row = 0; row < SUDOKU_SIZE; row++) {
                    if (nextBoard[row][col][num] === 1) {
                        possiblePositions.push([row, col]);
                    }
                }
                if (possiblePositions.length === 1) {
                    // 该数字在该行中只有一个可能位置
                    const [i, j] = possiblePositions[0];
                    nextBoard[i][j][0] = num;
                    updateCandidates(i, j);  // 更新候选值矩阵
                    isChange = true;
                }
            }
        }

        //last remaining cell in box
        for (let boxX = 0; boxX < 3; boxX++) {
            for (let boxY = 0; boxY < 3; boxY++) {
                for (let num = 1; num <= 9; num++) {
                    let possiblePositions = [];
                    const boxStartX = boxX * 3;
                    const boxStartY = boxY * 3;
                    for (let i = boxStartX; i <= boxStartX + 2; i++) {
                        for (let j = boxStartY; j <= boxStartY + 2; j++) {
                            if (nextBoard[i][j][num] === 1) {
                                possiblePositions.push([i, j]);
                            }
                        }
                    }
                    if (possiblePositions.length === 1) {
                        // 该数字在该盒子中只有一个可能位置
                        const [i, j] = possiblePositions[0];
                        nextBoard[i][j][0] = num;
                        updateCandidates(i, j);  // 更新候选值矩阵
                        isChange = true;
                    }
                }
            }
        }

        //the last possible number
        for(let row = 0; row < SUDOKU_SIZE; row++){
            for(let col = 0; col < SUDOKU_SIZE; col++){
                if(nextBoard[row][col][0] === 0){
                    let possibleNum = [];
                    for(let num = 1; num <= 9; num++){
                        if(nextBoard[row][col][num] === 1){
                            possibleNum.push(num);
                        }
                    }
                    if(possibleNum.length === 1){
                        nextBoard[row][col][0] = possibleNum[0];
                        updateCandidates(row, col);
                        isChange = true;
                    }
                }
            }
        }
    }

}

